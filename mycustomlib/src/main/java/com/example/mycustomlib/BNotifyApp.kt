package com.example.mycustomlib

import android.Manifest
import android.app.Activity
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.util.Log
import androidx.annotation.NonNull
import androidx.core.content.ContextCompat
import com.convex.notifyrfp.Bnotify.services.firebase.FirebaseManual
import com.example.mycustomlib.activity.PermissionRequestActivity
import com.example.mycustomlib.config.GeneratedConfig
import com.example.mycustomlib.model.BnotifyConfig
import com.example.mycustomlib.model.NotificationModel
import com.example.mycustomlib.receiver.NotificationDismissReceiver
import com.example.mycustomlib.socket.SocketManager
import com.example.mycustomlib.utils.PrefsHelper
import com.google.android.gms.tasks.OnCompleteListener
import com.google.android.gms.tasks.Task
import com.google.firebase.messaging.FirebaseMessaging
import org.json.JSONObject
import kotlin.apply
import kotlin.jvm.java
import kotlin.text.toIntOrNull

object BNotifyApp {
    private const val PERMISSION_REQUEST_CODE = 1001
    private var activityClass: Class<out Activity>? = null

    private var notification_listener:OnNotificationListener? = null

    private var isAutoGeneratedNotification = true;

    fun initialize(context: Context,intent: Intent, activity: Class<out Activity>){
        var configs: BnotifyConfig = readBNotifyConfig()!!
        FirebaseManual.initialize(context, configs)
        FirebaseMessaging.getInstance().getToken()
            .addOnCompleteListener(object : OnCompleteListener<String?> {
                override fun onComplete(@NonNull task: Task<String?>) {
                    if (!task.isSuccessful()) {
                        Log.w("SocketManager", "Fetching FCM registration token failed", task.getException())
                        return
                    }

                    // Get new FCM registration token
                    val token = task.getResult()
                    if (token != null) {
                        PrefsHelper.saveFcmToken(context.applicationContext, token)
                        SocketManager.FCM_TOKEN = token
                    }
                    // Log and toast
                    Log.i("SocketManager", "FCM onComplete ${token}")
                    setActivityToOpenOnClick(activity)
//                    if (!RunFCMOnly()){
//                        startPersistentService(context)
////                    scheduleAlarmManager(context)
//                        scheduleSocketMonitor(context)
//                    }else{
//                        SocketManager.initialize(context.applicationContext)
//                        SocketManager.connect()
//                    }
                    SocketManager.initialize(context.applicationContext)
                    SocketManager.connect()
                    notificationInitializer(context,intent)
                    context.restartConsumerService(intent)
                }
            })
    }

    fun setIsAutoGeneratedNotification(context: Context, enable: Boolean){
        isAutoGeneratedNotification = enable
        PrefsHelper.saveAutoGeneratedNotification(context, isAutoGeneratedNotification)
    }

    internal fun readBNotifyConfig(): BnotifyConfig? {
        val json = GeneratedConfig.JSON ?: return null // safe null check

        return try {
            val jsonObject = JSONObject(json)
            Log.i("Bnotify", "Extracted DATA: $json")

            BnotifyConfig(
                projectId = jsonObject.optString("projectId"),
                packageName = jsonObject.optString("packageName"),
                apiKey = jsonObject.optString("apiKey"),
                authDomain = jsonObject.optString("authDomain"),
                databaseURL = jsonObject.optString("databaseURL"),
                storageBucket = jsonObject.optString("storageBucket"),
                messagingSenderId = jsonObject.optString("messagingSenderId"),
                appId = jsonObject.optString("appId"),
                measurementId = jsonObject.optString("measurementId"),
                fcmAppId = jsonObject.optString("fcmAppId"),
                fcmProjectId = jsonObject.optString("fcmProjectId"),
                fcmApiKey = jsonObject.optString("fcmApiKey"),
                fcmSenderId = jsonObject.optString("fcmSenderId")
            )
        } catch (e: Exception) {
            Log.e("Bnotify", "Failed to parse config: ${e.message}")
            null
        }
    }

    internal fun getIsAutoGeneratedNotification(context: Context): Boolean{
        isAutoGeneratedNotification = PrefsHelper.isAutoGeneratedNotification(context)!!
        return isAutoGeneratedNotification
    }

    internal fun setActivityToOpenOnClick(activity: Class<out Activity>){
        this.activityClass = activity
    }

    internal fun getActivityToOpenOnClick(context: Context): Class<out Activity> {
        return activityClass
            ?: context.getLauncherActivityClass()
            ?: throw kotlin.IllegalStateException("No launcher activity found in manifest")
    }

    fun setNotificationListener(listener: OnNotificationListener){
        this.notification_listener = listener
    }

    internal fun getNotificationListener(): OnNotificationListener? {
        return this.notification_listener
    }

    internal fun notificationInitializer(activityContext: Context,intent: Intent) {
        if (ContextCompat.checkSelfPermission(
                activityContext,
                Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED
        ) {
//            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
//                checkAndRequestExactAlarmPermission(activityContext)
//            }

            if (intent.extras != null){
                val action = intent.getStringExtra("action")
                val type = intent.getStringExtra("type")
                val notification_id = intent.getStringExtra("notification_id")

                Log.i("Notification_SocketIO", "CLICKED Notification ID: $notification_id ACTION: $action TYPE: $type")
                val receiverIntent = Intent(activityContext, NotificationDismissReceiver::class.java).apply {
                    putExtra("notification_id", notification_id ?: 0)
                    putExtra("action", "clicked") // Action when dismissed
                    putExtra("type", type ?: null)
                    putExtra("click", true)
                }
                activityContext.sendBroadcast(receiverIntent)
            }else{
                Log.i("Notification_SocketIO", "No notification data")
            }
        } else {
            // Start permission activity
            val intent = Intent(activityContext, PermissionRequestActivity::class.java).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
                putExtra(
                    "request_code",
                    PERMISSION_REQUEST_CODE
                )
            }
            activityContext.startActivity(intent)
        }

    }


    private fun Context.getLauncherActivityClass(): Class<out Activity>? {
        val pm = packageManager
        val launchIntent = pm.getLaunchIntentForPackage(packageName) ?: return null
        val component = launchIntent.component ?: return null

        return try {
            Class.forName(component.className) as Class<out Activity>
        } catch (e: ClassNotFoundException) {
            null
        }
    }

    internal fun Context.restartConsumerService(intent: Intent){
        startService(intent)
    }

    fun setOnNotificationReceived(model: NotificationModel){
        if (SocketManager.isConnected()){
            SocketManager.handleNotificationReceived(model)
        }
    }

    fun setOnNotificationDismissed(context: Context, pendingIntentFlags:Int, model: NotificationModel): PendingIntent{
        val dismissIntent = Intent(context, NotificationDismissReceiver::class.java).apply {
            putExtra("notification_id", model.notificationId ?: 0)
            putExtra("action", "dismissed") // Action when dismissed
            putExtra("type", model.type ?: null)
            putExtra("click", false)
        }

        val dismissPendingIntent = PendingIntent.getBroadcast(
            context,
            (model.notificationId?.toIntOrNull() ?: System.currentTimeMillis().toInt()) + 1, // Different request code
            dismissIntent,
            pendingIntentFlags
        )

        if (SocketManager.isConnected()){
            SocketManager.handleNotificationDismissedIntent(dismissIntent)
        }

        return dismissPendingIntent
    }

    fun setOnNotificationClicked(intent: Intent){
        if (SocketManager.isConnected()){
            if (intent.extras!=null){
                val action = intent.getStringExtra("action")
                val click = intent.getBooleanExtra("click", false)
                val notificationId = intent.getStringExtra("notification_id")
                Log.d("Notification_SocketIO", "Notification ID: $notificationId ACTION: $action CLICKED: $click")
                if (click){
                    SocketManager.handleNotificationClickedIntent(intent)
                }
            }
        }
    }



    interface OnNotificationListener{
        fun onMessageReceive(remoteMessage: NotificationModel?)
    }
}